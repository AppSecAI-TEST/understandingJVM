# 深入理解Java虚拟机 #

---

## Chapter 3, 垃圾收集器与内存分配策略 ##

### 3.1 概述 ###

> 垃圾收集（Garbage Collection , GC）的历史远远比Java久远。它需要完成三件事：
>  
- 哪些内存需要回收
- 什么时候回收
- 如何回收    

> 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧需要分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但是大体上可以认为是编译器可知的），因此在这几个区域的内存分配和回收都具有确定性，这几个区域不太需要过多地考虑回收的问题。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分的内存分配和回收都是动态的，垃圾收集器需要关注的是这部分内存，我们所讨论的“内存”分配与回收也仅仅指着一部分。

### 3.2 对象已死？ ###
> 堆中存放着Java世界中几乎所有的对象，垃圾收集器在对堆进行回收前，第一件事就是要确定哪些对象还“存活着”，哪些已经“死去”（即不可能再被任何途径使用的对象）。

#### 3.2.1 引用计数算法 ####
> 引用计数算法（Reference Counting）：给对象添加一个引用计数器，每当有一个地方引用它时，计数器的数值就加1；当引用实效时，计数器数值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。    
> 实际上，Java并没有采用引用计数算法，因为它很难解决对象之间的相互循环引用的问题。    

#### 3.2.2 根搜索算法 ####
> 在主流的商业程序语言中（Java和C#），都是使用根搜索算法（GC Roots Tracing）来判定对象是否存活的。
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 